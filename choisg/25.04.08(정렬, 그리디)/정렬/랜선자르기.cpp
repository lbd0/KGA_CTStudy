//문제
//
//집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다.박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.
//이미 오영식은 자체적으로 K개의 랜선을 가지고 있다.그러나 K개의 랜선은 길이가 제각각이다.
//박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다.
//예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)
//편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자.
//그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자.N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
//이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.
//
//## 입력
//
//첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다.
//K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다.그리고 항상 K ≦ N 이다.
//그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다.랜선의 길이는 231 - 1보다 작거나 같은 자연수이다.
//
//## 출력
//
//첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.
//
//## 예제 입력 1
//
//4 11
//802
//743
//457
//539
//
//## 예제 출력 1
// 
//200
//
//## 힌트
//
//802cm 랜선에서 4개, 743cm 랜선에서 3개, 457cm 랜선에서 2개, 539cm 랜선에서 2개를 잘라내 모두 11개를 만들 수 있다.

#include <iostream>
#include <vector>
using namespace std;

// 
// 퀵정렬-병합정렬은 공용 폴더에 올렸으니 생략할게요
// 
// 줄줄이 쓰는 것보다는 처음에 설명하는 편이 나을 것 같아 그렇게 써보려 합니다. 틀릴 수 있습니다..
// 
// 이 문제가 왜 이분탐색 문제인지부터 이해해야 합니다. 이분탐색이 정렬된 배열에서 원하는 값을 찾는 알고리즘으로 잘 알려져 있지만
// 핵심 로직이 <중간 범위를 설정하고 범위를 반씩 줄이며 내가 찾는 값이 있는지를 탐색하는 것>이라는 점도 알고 계시죠.
// 이 문제에서 찾아야 하는 건 'K개의 랜선을 N개로 나눈다고 할 때 랜선 1개의 최대 길이' 입니다.
// 해당 최대 길이를 찾으려면 기존에 있는 'K개의 랜선 중 최대 길이'를 찾아야 합니다. 
// 왜냐면 K개의 랜선을 다시 N개로 나눈다고 할 때 K개의 랜선 중 가장 긴 랜선보다 길게 자르는건 불가능하니까요
// 다시 말해 K개의 랜선 중 최대 길이를 기준으로 정답(N개로 나눌 떄 랜선 1개의 최대 길이)의 범위를 좁혀 나가는 것이 필요한 문제입니다. 
// 게다가 K개의 랜선 중 최대 길이를 최대 값으로 설정하면 해당 값이 '정수이기 때문에' 자동으로 정렬돼 있는 상태니 딱 좋습니다. 

// 이해가 안되면 문제 예문을 보면서 다시 파악해봅시다. 
// 랜선 4개(K가 4로 입력됐으니 4개. 각각 길이가 802cm, 743cm, 457cm, 539cm)를 이용해서 11개(N개)의 동일한 길이의 랜선을 만들고 싶다네요.
// 주어진 K개의 랜선 중 길이가 최대인 랜선은 802cm입니다. 이 값의 반을 기준으로(401cm) 동일한 길이 랜선 11개를 만들 수 있을까요? 아니죠. 
// 802cm 랜선은 2개, 743과 457과 539 랜선은 겨우 1개 만들고 나머지 랜선은 버려야 합니다.
// 그러면 401보다는 작은 값으로 정답을 찾아봐야겠구나! 이런 생각이 들죠? 이분탐색을 이용해 이번엔 401의 절반인 200(int)을 기준점으로 삼아봅시다.
// 이제는 802cm 랜선은 4개, 743cm는 3개, 457과 539는 각각 2개를 자를 수 있죠? 바로 11개를 만들 수 있으니 200이 정답입니다.
// 만약에 계속 반으로 줄여봐도 N개의 값을 구할 수 없다-> 그러면 mid를 약간 조정하는 방식으로 정답을 찾아나갈 수 있겠죠.
// 그 부분이 코드에 구현돼 있습니다.
// 
// 
// 
// 
int findMaxLanCableLength(int K, int N, vector<int>& givenLength ) {

    // K개의 랜선이 주어지고 N개의 랜선을 만듦. k개의 랜선은 길이가 정해져 값으로 들어옴(givenLength)

    int maxLen = 0;
    for (int i = 0; i < K; ++i) {   // 가장 긴 랜선의 길이를 찾음 -> 이진 탐색의 right 경계로 활용
        if (givenLength[i] > maxLen) {
            maxLen = givenLength[i];
        }
    }

    // 이진 탐색 범위 설정
    int left = 1;
    int right = maxLen;
    int answer = 0;

    // 이진 탐색
    while (left <= right) {
        int mid = (left + right) / 2;

        // 잘려 나오는 랜선 조각의 총 개수
        int count = 0;
        for (int i = 0; i < K; ++i) {
            count += (givenLength[i] / mid); //주어진 길이를 mid로 나눈 값이 랜선 조각의 총개수가 됨. 
        }

        // N개 이상 만들 수 있다면 mid를 늘려본다.
        // 
        // 예시
        // 
        //  1    2    3    4    5 | 6    7    8    9    10
        //       (이미 충분)   
        //                    left=(mid + 1)           right
       

        if (count >= N) {
            answer = mid;      // 가능한 길이이므로 기록
            left = mid + 1;    // 더 긴 길이 탐색
        }
        // N개 미만이라면 mid를 줄인다.
        else {
            right = mid - 1;
        }
    }
    return answer;


}


int main() {
    // 입력 받기
    int K, N;
    cin >> K >> N;

   
        // K개의 랜선 길이 입력받기
        vector<int> givenLength(K);
    for (int i = 0; i < K; ++i) {
        cin >> givenLength[i];
    }

    // 함수 호출 -> 최대 길이 계산
    int result = findMaxLanCableLength(K, N, givenLength);

    // 결과 출력
    cout << result << endl;

}